% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/excel.R
\name{save_data_wb_split}
\alias{save_data_wb_split}
\title{Write a list of data.frames to an existing Workbook (one sheet per table)}
\usage{
save_data_wb_split(
  data,
  wb,
  rc = c(1L, 1L),
  row_names = FALSE,
  sheet_names = NULL,
  data_titles = NULL,
  title_size = 14,
  font_name = getOption("instead.font"),
  font_size = 11,
  fg_fill = "#E6E6E7",
  border_color = "#000000",
  widths = 8.43,
  auto_width = TRUE,
  num_fmt = NULL
)
}
\arguments{
\item{data}{A data.frame, or a (named/unnamed) list of data.frames/matrices.
Matrices are coerced to data.frames. A single object is treated as a
length-1 list.}

\item{wb}{An existing \code{openxlsx} \code{Workbook} (e.g., from
\code{openxlsx::createWorkbook()} or \code{openxlsx::loadWorkbook()}).}

\item{rc}{Integer vector \code{c(row, col)} giving the common start cell for all
sheets. Default \code{c(1L, 1L)}.}

\item{row_names}{Logical; whether to include row names when writing tables.
Default \code{FALSE}.}

\item{sheet_names}{Optional character vector of sheet names; must have
\code{length(sheet_names) == length(data)} if supplied. If \code{NULL}, falls back
to \code{names(data)} or \code{"Sheet {i}"}.}

\item{data_titles}{Optional character vector of titles to write \strong{above}
each table; must have \code{length(data_titles) == length(data)} if supplied.
If \code{NULL}, no titles are written.}

\item{title_size}{Numeric font size for title rows. Default \code{14}.}

\item{font_name, font_size, fg_fill, border_color, widths}{Styling forwarded to
\code{\link[=write_data]{write_data()}}. \code{widths} is only used when \code{auto_width = FALSE}.}

\item{auto_width}{Logical. If \code{TRUE}, compute per-column widths and set
via \code{openxlsx::setColWidths()} for \strong{data columns only}. Default \code{TRUE}.}

\item{num_fmt}{Optional numeric format(s) applied to data cells (headers
excluded). Either a single character (applied to all numeric columns)
or a named character vector/list mapping column names to formats
(unknown names are ignored).}
}
\value{
The modified \code{Workbook} (invisibly).
}
\description{
Writes each element of \code{data} to its \strong{own worksheet} in an existing
\code{openxlsx} workbook. Optionally writes a \strong{title row} above each table and
auto-sizes \strong{data columns} (title rows are excluded from width calculation).
This function \strong{does not save} the workbook; it returns the modified
\code{Workbook} so you can call \code{openxlsx::saveWorkbook()} yourself.
}
\details{
Sheet names are resolved in this order:
\enumerate{
\item \code{sheet_names} (if provided)
\item \code{names(data)} (when available)
\item \code{"Sheet 1"}, \code{"Sheet 2"}, ...
}
\itemize{
\item Titles are written via \code{write_cell()} (bold, left-aligned).
\item Tables are written via \code{write_data()} (borders, header/body/footer styles,
numeric formats).
\item Column widths are set relative to the tableâ€™s starting column and do not
include the optional title row.
}
}
\examples{
\dontrun{
wb <- openxlsx::createWorkbook()
save_data_wb_split(
  data        = list(iris_tab = head(iris), mtcars_tab = head(mtcars)),
  wb          = wb,
  rc          = c(1, 1),
  data_titles = c("Iris (head)", "Mtcars (head)"),
  auto_width  = TRUE
)
openxlsx::saveWorkbook(wb, "by_sheet.xlsx", overwrite = TRUE)
}

}
\seealso{
\code{\link[=save_data_xlsx_split]{save_data_xlsx_split()}}, \code{\link[=write_data]{write_data()}}, \code{\link[=write_cell]{write_cell()}}
}
