% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/excel.R
\name{save_data_xlsx}
\alias{save_data_xlsx}
\title{Save multiple data.frames to one sheet (stacked), with optional titles and auto-widths}
\usage{
save_data_xlsx(
  data,
  file,
  sheet = "Data",
  rc = list(c(1L, 1L)),
  row_spacer = 2L,
  data_titles = NULL,
  title_size = 14,
  row_names = FALSE,
  font_name = getOption("instead.font"),
  font_size = 11,
  fg_fill = "#E6E6E7",
  border_color = "#000000",
  widths = 8.43,
  auto_width = TRUE,
  width_scope = c("global_max", "per_table"),
  num_fmt = NULL,
  overwrite = FALSE
)
}
\arguments{
\item{data}{A data.frame, matrix, or a list of them. If a single object
is supplied it is treated as length-1 list.}

\item{file}{Path to the \code{.xlsx} file. Created if it does not exist.}

\item{sheet}{Target sheet name (created if missing). Default \code{"Sheet 1"}.}

\item{rc}{Either a single length-2 integer vector \code{c(row, col)} (to stack),
or a list of such vectors with the same length as \code{data} (to place individually).}

\item{row_spacer}{Integer (>= 0). Number of \strong{blank rows between stacked tables}
when \code{rc} has length 1. Default \code{2L}.}

\item{data_titles}{Optional character vector of table titles. If provided and
length matches \code{length(data)}, these are written \strong{above} each table.
If \code{data_titles} is \code{NULL}, \code{names(data)} are used when available.
If neither is available, no title is written for that table.}

\item{title_size}{Numeric font size for titles. Default \code{14}.}

\item{row_names}{Logical; forwarded to \code{\link[=write_data]{write_data()}} to include row names
in the written table. Default \code{FALSE}.}

\item{font_name, font_size, fg_fill, border_color, widths}{Styling; forwarded to
\code{\link[=write_data]{write_data()}}. \code{widths} is used when \code{auto_width = FALSE}.}

\item{auto_width}{Logical. If \code{TRUE}, compute per-column widths from the
underlying data (and optional row-name column) and call
\code{openxlsx::setColWidths()} \strong{for data columns only}. Title rows are ignored.
Default \code{TRUE}.}

\item{width_scope}{One of \code{"per_table"} or \code{"global_max"}. When \code{auto_width = TRUE}:
\itemize{
\item \code{"per_table"} sets column widths independently \strong{after each table}.
\item \code{"global_max"} first scans all tables that start at the \strong{same start column},
takes the \strong{maximum width per column} across them, then applies widths \strong{once},
preventing later tables from overwriting the widths set by earlier ones.
Default \code{"global_max"}.
}}

\item{num_fmt}{Optional numeric format(s) applied to data cells (headers
excluded). Accepts either:
\itemize{
\item A \strong{single character format string} applied to all numeric cells
(e.g. \code{"0.00"} for 2 decimals, \code{"#,##0"} for thousands separator,
\code{"0.00\%"} for percentages).
\item A \strong{named character vector or list} mapping column names to formats,
e.g. \code{c(value = "#,##0", rate = "0.0\%")}. Columns not listed are left
unchanged. Unknown column names are silently ignored.
}}

\item{overwrite}{Logical; passed to \code{openxlsx::saveWorkbook()}. Default \code{FALSE}.}
}
\value{
(Invisibly) the path to \code{file}. Side-effects: creates/updates an Excel file.
}
\description{
Writes one or more rectangular tables to a single Excel worksheet using
\code{openxlsx}, stacking them vertically with a configurable blank spacer
between tables. Optionally writes a \strong{title row} above each table and
auto-sizes the \strong{data columns} (titles are excluded from width calculation).
}
\details{
If \code{rc} has \strong{length 1}, the first table is written at that \verb{(row, col)},
and subsequent tables are placed \strong{below it}, leaving \code{row_spacer} blank
row(s) between tables. The next top-left row is computed as:

\preformatted{
start_row_next = start_row
               + title_height              # 1 if a title is written, else 0
               + 1L                        # header row
               + nrow(df)                  # data rows
               + row_spacer                # blank rows between tables
}

If \code{rc} has the same length as \code{data}, each table is written to its own
specified top-left cell, with no automatic stacking.

Matrices are accepted and coerced to data.frames. Vectors or character
scalars are not supported.
}
\section{Notes}{

\itemize{
\item This function uses an existing helper \code{\link[=write_data]{write_data()}} for writing a single table
with styling. Column auto-sizing (when enabled) ignores the title row.
\item Column widths are set relative to the table's starting column. If \code{row_names = TRUE},
the first (row-name) column is included in auto-width calculation and width setting.
}
}

\examples{
\dontrun{
data1 <- head(iris)
data2 <- head(mtcars)

# Stack two tables on one sheet (A1 start), with titles & unified widths
save_data_xlsx(
  data        = list(iris_head = data1, mtcars_head = data2),
  data_titles = c("iris (head)", "mtcars (head)"),
  file        = "data.xlsx",
  sheet       = "Summary",
  rc          = list(c(1, 1)),
  row_spacer  = 2L,
  auto_width  = TRUE,
  width_scope = "global_max",
  overwrite   = TRUE
)

# Place at specific cells (no stacking)
save_data_xlsx(
  data        = list(A = data1, B = data2),
  data_titles = c("Block A", "Block B"),
  file        = "block.xlsx",
  sheet       = "Placed",
  rc          = list(c(1, 1), c(1, 10)),  # A1 and J1
  auto_width  = TRUE,
  width_scope = "per_table",
  overwrite   = TRUE
)
}

}
\seealso{
\code{\link[=save_data_xlsx_split]{save_data_xlsx_split()}}, \code{\link[=write_data]{write_data()}}
}
