% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/time.R
\name{cache_in_time_window}
\alias{cache_in_time_window}
\title{Cache-aware switching based on a rolling time window}
\usage{
cache_in_time_window(
  cache_timestamp,
  at_time,
  window_days = 1L,
  tz = "Asia/Seoul",
  use_cache,
  refresh,
  use_cache_args = list(),
  refresh_args = list(),
  verbose = FALSE
)
}
\arguments{
\item{cache_timestamp}{A POSIXct/POSIXlt timestamp indicating when the
cache was last updated (e.g., \code{file.info(path)$mtime}). May be \code{NA}
or \code{NULL}, in which case the cache is treated as missing and
\code{refresh()} is executed.}

\item{at_time}{Character string \code{"HH:MM"} (24-hour format) defining the
daily cutoff time used as the center/anchor of the decision window.}

\item{window_days}{Integer number of days used to build the time window
around (or adjacent to) \code{at_time}. Defaults to \code{1L}. See Details.}

\item{tz}{Time zone used for \code{Sys.time()} and to interpret \code{at_time}.
Defaults to \code{"Asia/Seoul"}.}

\item{use_cache}{A function to call when \code{cache_timestamp} falls within
the computed time window (i.e., cache is considered "fresh").}

\item{refresh}{A function to call when the cache is missing or when
\code{cache_timestamp} lies outside the time window (i.e., cache is
considered "stale").}

\item{use_cache_args}{A named list of arguments to pass to \code{use_cache()}
via \code{do.call()}. Defaults to an empty list.}

\item{refresh_args}{A named list of arguments to pass to \code{refresh()}
via \code{do.call()}. Defaults to an empty list.}

\item{verbose}{Logical; if \code{TRUE}, prints diagnostic information about
the current time, cutoff time, window bounds, and cache timestamp.}
}
\value{
The return value of either \code{use_cache()} or \code{refresh()}, depending on
whether the cache is within the time window.
}
\description{
\code{cache_in_time_window()} decides whether to reuse existing cached data
or refresh it, based on when the cache was last updated relative to a
daily cutoff time and a rolling time window.
}
\details{
The function compares a \code{cache_timestamp} (e.g., file modification time)
with a window around today's cutoff time \code{at_time}. If the timestamp
lies within the window, \code{use_cache()} is called; otherwise \code{refresh()}
is called.

Let \code{now} be the current time in \code{tz}, and \code{cutoff} be today's date at
\code{at_time} in the same time zone.
\itemize{
\item If \code{now >= cutoff}, the window is
\verb{[cutoff, cutoff + window_days days]}.
\item If \code{now < cutoff}, the window is
\verb{[cutoff - window_days days, cutoff]}.
}

The cache is considered "fresh" when:

\preformatted{
  cache_timestamp > window_start && cache_timestamp < window_end
}

(strict inequalities, matching typical "recently updated" checks).

If \code{cache_timestamp} is \code{NULL} or \code{NA}, the function always falls back
to \code{refresh()}.

This helper is useful for patterns such as:
\itemize{
\item "If a file was saved between yesterday 15:30 and today 15:30,
reuse it; otherwise, download new data and overwrite the file."
}
}
\examples{
\dontrun{
# Suppose you compute some expensive result and want to cache it.
cache_path <- "cache/result.rds"

# Load previous cache timestamp if it exists
ts <- if (file.exists(cache_path)) file.info(cache_path)$mtime else NA

result <- cache_in_time_window(
  cache_timestamp = ts,
  at_time         = "09:00",   # daily cutoff at 9 AM
  window_days     = 1L,        # accept cache from the last 24 hours
  tz              = "Asia/Seoul",

  # Function used when cache is fresh
  use_cache = function() readRDS(cache_path),

  # Function used when cache is stale or missing
  refresh = function() {
    x <- runif(5)        # pretend this is an expensive computation
    saveRDS(x, cache_path)
    x
  },

  verbose = TRUE
)
}

}
